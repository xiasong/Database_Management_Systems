DSE 201 Final --- Winter 2017

—-True and False

1. Consider a schema in which each pair of distinct tables has disjoint column names. Then every SQL query Q with aliases (tuple variables) over this schema can be reformulated to a query Q' without aliases, over the same schema, such that Q' always returns the same answer as Q on every input database.TRUE2. SELECT * FROM T WHERE T.A < = 39 OR T.A >  39 always returns the same result as SELECT * FROM T.FALSE3. NATURAL LEFT JOIN is SQL-expressible without the JOIN keyword.FALSE4. SELECT DISTINCT T.A FROM T is SQL-expressible without the DIS-TINCT keyword.FALSE5. SELECT MAX (R.A) FROM R can be expressed without the MAX built-in aggregate, ORDER BY, LIMIT, TOP K, WINDOWand without UDFs.FALSE6. Let R(A,B) and S(B,C) be tables whose underlined attributes are primary keys. Attribute R.B is not null, and it is a foreign key referencing S. SELECT r.A FROM R r, S s WHERE r.B = s.B always returns the same answer as SELECT A FROM R.FALSE7. EXCEPT can be expressed in SQL without using the EXCEPT keyword or UDFs.FALSE8. In SQL, all nested queries without correlated variables can be unnested (without creating views or auxiliary tables).FALSE9. Consider tables R(A,B) and S(A,B). Then SELECT A FROM (R UNION S) always returns the same result as (SELECT A FROM R) UNION (SELECT A FROM S).FALSE10. Let R(A,B) be a relation with primary key A and numeric, not-null B. Then SELECT A, MAX(B) FROM R GROUP BY A returns R.FALSE


—-Problem 2

--Create schemaCREATE TABLE soccer.teams(teamnames  varchar(500) primary key NOT NULL,coach varchar(500) NOT NULL)CREATE TABLE soccer.matches(hteam varchar(500)  references soccer.teams (teamnames) NOT NULL,vteam varchar(500)  references soccer.teams (teamnames) NOT NULL,hscore integer NOT NULL,vscore integer NOT NULL)--load data
COPY teams FROM '/Users/xiasong/Documents/teams.csv' DELIMITER ',' CSV;COPY matches FROM '/Users/xiasong/Documents/matches.csv' DELIMITER ',' CSV;--sql query(i)
CREAT VIEW soccer.wins(tname)SELECT m.hteamFROM soccer.matches mWHERE m.hscore > m.vscoreUNION ALLSELECT m.vteam FROM soccer.matches mWHERE m.hscore < m.vscoreSELECT COUNT(*)FROM soccer.winsWHERE tname = ‘fox’(ii)CREATE VIEW soccer.points(tname, point) ASSELECT m.hteam, 1 as pointFROM matches mWHERE m.hscore = m.vscoreUNION ALLSELECT m.vteam, 1 as pointFROM matches mWHERE m.hscore = m.vscoreUNION ALLSELECT m.hteam, 2 as pointFROM matches mWHERE m.hscore > m.vscoreUNION ALLSELECT m.vteam, 3 as pointFROM matches mWHERE m.hscore < m.vscoreSELECT tname, sum (point) as teampointsFROM soccer.pointsGROUP BY tname(iii)CREATE VIEW soccer.coach(tname) ASSELECT m.hteamFROM matches mWHERE NOT EXISTS (                  SELECT m.hteam                  FROM matches m                  WHERE m.hscore < m.vscore                  UNION ALL                  SELECT m.vteam                  FROM matches m                  WHERE m.vscore < m.hscore                  )SELECT t.coachFROM soccer.teams t, soccer.coach cWHERE t.teamnames = c.tname(iv)CREATE VIEW soccer.tscore(tname, tscore) ASSELECT tname, sum (point) as tscoreFROM soccer.points GROUP BY tnameCREATE VIEW soccer.tleader(tname) ASSELECT tnameFROM soccer.tscore WHERE tscore = (SELECT MAX(tscore) FROM soccer.tscore)                              CREATE VIEW soccer.wdteam(wteam, dteam) ASSELECT m.hteam, m.vteamFROM soccer.matches mWHERE m.hscore > m.vscoreUNION ALLSELECT m.vteam, m.hteamFROM soccer.matches mWHERE m.hscore < m.vscoreSELECT swd.dteamFROM soccer.wdteam swdWHERE NOT EXISTS (                  SELECT swd.dteam                  FROM soccer.wdteam swd, soccer.tleader sl                  WHERE swd.wteam <> sl.tname                  )(v)Because the both queries are all about on matches.hteam and matches.vteam, it is should be beneficial to add an index on the two variables.CREATE INDEX matches_hteam_idx ON soccer.matches USING btree (hteam)CREATE INDEX matches_vteam_idx ON soccer.matches USING btree (vteam)(vi)--Build the materialized viewCREATE MATERIALIZED VIEW soccer.points(tname, point) ASSELECT m.hteam, 1 as pointFROM matches mWHERE m.hscore = m.vscoreUNION ALLSELECT m.vteam, 1 as pointFROM matches mWHERE m.hscore = m.vscoreUNION ALLSELECT m.hteam, 2 as pointFROM matches mWHERE m.hscore > m.vscoreUNION ALLSELECT m.vteam, 3 as pointFROM matches mWHERE m.hscore < m.vscore--Triggering auto magical rebuild in event any dependency tables change.CREATE OR REPLACE FUNCTION trig_refresh_points() RETURNS trigger AS$$BEGIN	REFRESH MATERIALIZED VIEW points;
	RETURN NULL;END;$$LANGUAGE plpgsql;CREATE TRIGGER trig_01_refresh_points AFTER TRUNCATE OR INSERT OR UPDATE OR DELETE ON soccer.matches FOR EACH STATEMENT	EXECUTE PROCEDURE trig_refresh_points();